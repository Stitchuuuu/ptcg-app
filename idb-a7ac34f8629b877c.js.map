{"version":3,"file":"idb-a7ac34f8629b877c.js","sources":["webpack://ocr/./common/utils.js","webpack://ocr/./web/src/helpers/idb.js","webpack://ocr/./web/src/workers/idb.js"],"sourcesContent":["export const normalize = s => {\n\tif (typeof s !== 'string') console.log(s)\n\treturn s.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase()\n}\nexport const escapeRegex = s => s.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\nexport const uuid = s => (s ? s + '-' : '') + Date.now().toString(32) + '-' + Math.random().toString(32).substring(2)","import { normalize } from '@common/utils'\n\n/** @type {IDBDatabase} */\nlet db\n\n/**\n * Open the App IndexedDB and do the migrations\n */\nconst openCardsDB = () => new Promise((resolve, reject) => {\n\tconst request = indexedDB.open('app', 1)\n\trequest.onupgradeneeded = ev => {\n\t\tconst db = request.result\n\t\tif (!ev.oldVersion) {\n\t\t\tdb.createObjectStore('cards')\n\t\t\tdb.createObjectStore('abilities')\n\t\t\tdb.createObjectStore('attacks')\n\t\t}\n\t}\n\trequest.onerror = () => {\n\t\tconsole.error('[indexeddb]', request.error)\n\t\treject(request.error)\n\t}\n\trequest.onsuccess = ev => {\n\t\tresolve(ev.target.result)\n\t}\n})\n\n/**\n *\n * @param {IDBDatabase} db\n * @param {String|String[]} name\n * @param {IDBTransactionMode} mode\n * @param {(store: IDBObjectStore) => void} callback\n * @returns {Promise<IDBObjectStore>}\n */\nconst doInStore = (db, name, mode, callback) => new Promise((resolve, reject) => {\n\tconst tr = db.transaction(name, mode)\n\ttr.oncomplete = resolve\n\ttr.onerror = reject\n\tcallback(tr.objectStore(name))\n})\n\nconst initProcess = Promise.all([\n\ttypeof window !== 'undefined' ? fetch('/db.json', { cache: 'no-cache' }).then(res => res.json()).catch(() => null) : Promise.resolve(),\n\topenCardsDB(),\n])\n\nexport const processStore = async (name, ...args) => {\n\tawait initProcess\n\t\n\tlet options = {}\n\tif (typeof args[1] === 'object') options = args[1]\n\tconst fn = args.pop()\n\treturn doInStore(db, name, options.mode || 'readonly', fn)\n}\n\ninitProcess.then(async ([cards, _db]) => {\n\t/** @type {IDBDatabase} */\n\tdb = _db\n\tif (!cards) return\n\n\t// Filling database with all the cards\n\t// TODO: Do the update in a separate process, and dont fetch always all the cards\n\tawait doInStore(db, 'cards', 'readwrite', store => {\n\t\tfor (const card of cards) {\n\t\t\tcard.search = [\n\t\t\t\tcard.id,\n\t\t\t\t`${card.ext} ${card.extId}`,\n\t\t\t\tnormalize(card.fr?.name || ''),\n\t\t\t\tnormalize(card.en?.name || ''),\n\t\t\t].filter(s => !!s).map(s => s.trim()).join('\\n')\n\n\t\t\tstore.put(card, card.id)\n\t\t}\n\t})\n})","import { processStore } from '@/helpers/idb'\nimport { escapeRegex, normalize } from '@common/utils'\n\nconst STANDARD_REGULATION_MARK = ['F', 'G', 'H']\n\nonmessage = async ev => {\n\tconst data = ev.data\n\tif ('searchCards' in data) {\n\t\tconst rows = []\n\t\tconst search = {\n\t\t\tall: false,\n\t\t\tkeywords: '',\n\t\t\tinCardName: true,\n\t\t\tinAttackDescs: false,\n\t\t\tinAttacksOrAbilities: true,\n\t\t\tprops: {},\n\t\t}\n\t\tif (typeof data.searchCards === 'string') {\n\t\t\tsearch.keywords = data.searchCards\n\t\t} else if (typeof data.searchCards === 'object') {\n\t\t\tObject.assign(search, data.searchCards)\n\t\t}\n\t\tconst keywords = !search.keywords ? [] : search.keywords.split(/\\s+/).map(k => new RegExp(escapeRegex(normalize(k)), 'ig'))\n\n\t\tawait processStore('cards', store => {\n\t\t\t/** @type {IDBObjectStore} */\n\t\t\tconst s = store\n\t\t\tconst request = s.openCursor()\n\t\t\trequest.onsuccess = event => {\n\t\t\t\t/** @type {IDBCursorWithValue} */\n\t\t\t\tconst cursor = event.target.result\n\t\t\t\tif (cursor) {\n\t\t\t\t\tconst card = cursor.value\n\t\t\t\t\tlet matched = false\n\t\t\t\t\tmatched ||= (search.all || STANDARD_REGULATION_MARK.includes(card.regulationMark))\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (matched) {\n\t\t\t\t\t\t\tmatched = true\n\t\t\t\t\t\t\tfor (const reg of keywords) {\n\t\t\t\t\t\t\t\tlet keywordMatched = false\n\t\t\t\t\t\t\t\tkeywordMatched ||= search.inCardName && card.search.match(reg)\n\t\t\t\t\t\t\t\tkeywordMatched ||= (search.inAttacksOrAbilities && (\n\t\t\t\t\t\t\t\t\tcard.en.attacks.find(atk => normalize(atk.name).match(reg)) ||\n\t\t\t\t\t\t\t\t\tcard.fr.attacks.find(atk => normalize(atk.name).match(reg)) ||\n\t\t\t\t\t\t\t\t\tcard.fr.abilities.find(ability => normalize(ability).match(reg)) ||\n\t\t\t\t\t\t\t\t\tcard.en.abilities.find(ability => normalize(ability).match(reg))\n\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\tkeywordMatched ||= (search.inAttackDescs && (\n\t\t\t\t\t\t\t\t\tcard.en.attacks.find(atk => atk.description && normalize(atk.description).match(reg)) ||\n\t\t\t\t\t\t\t\t\tcard.fr.attacks.find(atk => atk.description && normalize(atk.description).match(reg)) ||\n\t\t\t\t\t\t\t\t\t(card.en.description && normalize(card.en.description).match(reg)) ||\n\t\t\t\t\t\t\t\t\t(card.fr.description && normalize(card.fr.description).match(reg))\n\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\tmatched &&= keywordMatched\n\t\t\t\t\t\t\t\tif (!matched) break\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (const name in search.props) {\n\t\t\t\t\t\t\t\tlet val = search.props[name]\n\t\t\t\t\t\t\t\tif (!(val instanceof RegExp)) val = new RegExp(escapeRegex(val), 'i')\n\t\t\t\t\t\t\t\tmatched &&= (card[name] && card[name].toString().match(val))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.error('Card had an error', card, err)\n\t\t\t\t\t}\n\t\t\t\t\tif (matched) rows.push(card)\n\t\t\t\t\tcursor.continue()\n\t\t\t\t} else {\n\t\t\t\t\t// no more results\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tpostMessage(rows)\n\t} else {\n\t\tpostMessage(undefined)\n\t}\n}"],"names":["normalize","s","console","log","replace","toLowerCase","escapeRegex","doInStore","db","name","mode","callback","Promise","resolve","reject","tr","transaction","oncomplete","onerror","objectStore","initProcess","all","window","fetch","cache","then","res","json","catch","request","indexedDB","open","onupgradeneeded","ev","result","oldVersion","createObjectStore","error","onsuccess","target","async","cards","_db","store","card","search","id","ext","extId","fr","en","filter","map","trim","join","put","STANDARD_REGULATION_MARK","onmessage","data","rows","keywords","inCardName","inAttackDescs","inAttacksOrAbilities","props","searchCards","Object","assign","split","k","RegExp","args","options","fn","pop","processStore","openCursor","event","cursor","value","matched","includes","regulationMark","reg","keywordMatched","match","attacks","find","atk","abilities","ability","description","val","toString","err","push","continue","postMessage","undefined"],"mappings":"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"}