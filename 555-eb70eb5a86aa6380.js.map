{"version":3,"file":"555-eb70eb5a86aa6380.js","sources":["webpack://ocr/./web/src/sw/index.js"],"sourcesContent":["/** TODO: Separate in multiple files, and search how to only have one chunk name in dev mode */\nconst cacheName = 'cache-app'\nconst cacheImgName = 'cache-img'\nconst BASE_URL_IMG = 'https://pub-4211d6b528d54ed69e8ec217f023723e.r2.dev/'\nconst baseCacheResources = [\n\t'/',\n\t'/index.html',\n]\n\n/**\n * Open the App IndexedDB and do the migrations\n * @type {Promise<IDBDatabase>}\n */\nconst getCacheDB = new Promise((resolve, reject) => {\n\tconst request = indexedDB.open('cache', 1)\n\trequest.onupgradeneeded = ev => {\n\t\tconst db = request.result\n\t\tif (!ev.oldVersion) {\n\t\t\tdb.createObjectStore('config')\n\t\t}\n\t}\n\trequest.onerror = () => {\n\t\tconsole.error('[indexeddb]', request.error)\n\t\treject(request.error)\n\t}\n\trequest.onsuccess = ev => {\n\t\tresolve(ev.target.result)\n\t}\n})\n\nconst lsGetItem = async name => {\n\t/** @type {IDBDatabase} */\n\tconst db = await getCacheDB\n\treturn new Promise((resolve, reject) => {\n\t\tconst tr = db.transaction('config', 'readonly')\n\t\ttr.onerror = reject\n\t\tconst store = tr.objectStore('config')\n\t\tconst req = store.get(name)\n\t\treq.onsuccess = ev => {\n\t\t\tresolve(req.result)\n\t\t}\n\t})\n}\nconst lsSetItem = async (name, value) => {\n\t/** @type {IDBDatabase} */\n\tconst db = await getCacheDB\n\treturn new Promise((resolve, reject) => {\n\t\tconst tr = db.transaction('config', 'readwrite')\n\t\ttr.onerror = reject\n\t\tconst store = tr.objectStore('config')\n\t\tconst req = store.put(value, name)\n\t\treq.onsuccess = ev => {\n\t\t\tresolve(req.result)\n\t\t}\n\t})\n}\n\nconst IS_DEV = process.env.NODE_ENV === 'development'\n\nasync function clearAndCacheAppFiles() {\n\tawait caches.delete(cacheName)\n\treturn caches.open(cacheName).then(async cache => {\n\t\tconst manifest = await fetch('/manifest.json', { cache: 'no-store' }).then(res => res.json()).catch(() => ({}))\n\t\tlsSetItem('version', manifest.VERSION)\n\t\tdelete manifest.VERSION\n\n\t\tconst resources = [\n\t\t\t...baseCacheResources,\n\t\t\t...Object.values(manifest),\n\t\t].filter((url, idx, arr) => arr.indexOf(url) === idx)\n\t\treturn cache.addAll(resources).then(async res => {\n\t\t\tconsole.log(new Date(), 'Cached app version', await lsGetItem('version'))\n\t\t\treturn res\n\t\t})\n\t}).then(() => {\n\t\tconsole.log(new Date(), 'added all ressources to cache')\n\t})\n}\n\n// When the service worker is installing, open the cache and add the precache resources to it\nself.addEventListener('install', event => {\n\tself.skipWaiting()\n\tevent.waitUntil(Promise.resolve())\n\t\n\tif (IS_DEV) return\n\n\t// Cache the app asynchronously\n\tclearAndCacheAppFiles()\n})\nself.addEventListener('activate', ev => self.clients.claim())\n\n// When there's an incoming fetch request, try and respond with a precached resource, otherwise fall back to the network\nself.addEventListener('fetch', event => {\n\tconst url = event.request.url.toString()\n\tconst isImg = url.startsWith(BASE_URL_IMG)\n\tif (IS_DEV && !isImg) return fetch(event.request)\n\n\tevent.respondWith(\n\t\tcaches.match(event.request).then(async cachedResponse => {\n\t\t\tif (new URL(url).pathname === '/' || new URL(url).pathname === '/index.html') {\n\t\t\t\t// Checking if cache is accurate\n\t\t\t\tconst currentVersion = await lsGetItem('version')\n\t\t\t\tconst manifest = await fetch('/manifest.json', { cache: 'no-store' }).then(res => res.json()).catch(() => null)\n\t\t\t\tif (manifest && manifest.VERSION !== currentVersion) {\n\t\t\t\t\tconsole.log(new Date(), 'New version detected, removing cache and getting new files')\n\t\t\t\t\tclearAndCacheAppFiles()\n\t\t\t\t\treturn fetch(event.request)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cachedResponse) {\n\t\t\t\treturn cachedResponse\n\t\t\t}\n\t\t\tconst response = await fetch(event.request)\n\t\t\tif (isImg && (response.ok || response.type === 'opaque')) {\n\t\t\t\tcaches.open(cacheImgName).then(cache => cache.add(url)).catch(console.error)\n\t\t\t}\n\t\t\treturn response\n\t\t}),\n\t)\n})\n\nself.onmessage = ev => {\n\tif ('cache' in ev.data) {\n\t\tconst url = ev.data.cache\n\t\tconst isImg = url.startsWith(BASE_URL_IMG)\n\t\tif (isImg) {\n\t\t\tcaches.match(url).then(isCached => {\n\t\t\t\tif (isCached) return\n\t\t\t\tcaches.open(cacheImgName).then(cache => cache.add(url)).catch(console.error)\n\t\t\t})\n\t\t}\n\t}\n\tif ('getCache' in ev.data) {\n\t\tif (ev.data.getCache === 'img') {\n\t\t\tcaches.open(cacheImgName).then(async cache => {\n\t\t\t\tev.source.postMessage({\n\t\t\t\t\tcache: (await cache.keys()).reduce((map, s) => {\n\t\t\t\t\t\tmap[s.url] = true\n\t\t\t\t\t\treturn map\n\t\t\t\t\t}, {}),\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n}"],"names":["cacheName","cacheImgName","BASE_URL_IMG","baseCacheResources","getCacheDB","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","ev","db","result","oldVersion","createObjectStore","onerror","console","error","onsuccess","target","lsGetItem","async","tr","transaction","req","objectStore","get","name","clearAndCacheAppFiles","caches","delete","then","manifest","fetch","cache","res","json","catch","value","put","lsSetItem","VERSION","resources","Object","values","filter","url","idx","arr","indexOf","addAll","log","Date","self","addEventListener","event","skipWaiting","waitUntil","clients","claim","toString","isImg","startsWith","respondWith","match","URL","pathname","currentVersion","cachedResponse","response","ok","type","add","onmessage","data","isCached","getCache","source","postMessage","keys","reduce","map","s"],"mappings":"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"}